# 使用寄存器(Second）

## 汇编语言中的整数常量表示
  - 十进制整数:[十进制数]d或[十进制数]D
  - 十六进制数:0[十六进制数]h或0[十六进制数]H,第一位是数字，则开头的0可以省略，例如7fffh，0ffffh
  - 二进制数:[二进制数]b或[二进制数]B
  - 八进制数:[八进制数]q、[八进制数]Q、[八进制数]o、[八进制数]O

## 简单指令
     1.MOV指令
       mov eax,ebx			;ebx内容送入eax
       mov ecx,ebx			;edx内容送入ecx
     2.xchg指令
       xchg ebx,ecx，表示ebx与ecx的数值被交换
     3.递增（减）指令
       inc reg(8,16,32)(++1)
       dec reg(8,16,32)(--1)
     4.add指令
       将寄存器的数值与另一寄存器或立即数的值相加，并存回**此寄存器**
	   add reg32,reg32/imm(8,16,32)
       add reg16,reg16/imm(8,16)
       add reg8,reg8/imm(8)
     5.SUB指令（同上）
     6.lea指令
       目标地址传送指令：将一个近地址指针写入到指定的寄存器
	   lea reg16,mem16 （lea ax,buf 将存储器buf所指的地址传送给ax）
	   reg16必须是一个16位的通用寄存器，mem16必须是一个存储器。执行完这个指令后，就讲mem16所指的16位偏移地址传送到了reg16中。 
	   **MOV指令传送的是地址所指的内容，而LEA只是传地址**
     7.rep、stos指令
       lea edi,[ebp-0C0h]
       mov ecx,30h
       mov eax,0CCCCCCCCh
       rep stos dword ptr es:[edi]
	   其中，rep指令的作用是重复上面的指令，ECX的值是重复次数。TOS指令是将EAX中的值拷贝到一个目的地址(es:[edi])中。
	   REP指令可以是任何字符串指令（CMPS、LODS、MOVS、SCAS、STOS）的前缀，dword ptr（强制转换成dword格式）前缀是告诉stos，
	   一次拷贝双字（4个字节）到目的地址（为什么）
     8.逻辑运算
     逻辑运算指令qnrt包括AND, OR, XOR, TEST, NOT，逻辑运算的结果会影响到CF, PF, AF, ZF, OF标志位
	 [参考](http://blog.csdn.net/betabin/article/details/7306347)
     9.cmp指令
	   比较两个操作数的大小，进行的运算是第一个操作数减去第二个操作数，但结果不会影响两个操作数的值，只会影响flag的CF、ZF、OF、AF、PF
	   影响如下:
	   
	   若执行指令后
       ZF=1 这个简单，则说明两个数相等，因为zero为1说明结果为0
       当无符号时：
       若
       CF=1 则说明了有进位或借位，cmp是进行的减操作，故可以看出为借位，所以，此时oprd1<oprd2
       CF=0 则说明了无借位，但此时要注意**ZF是否为0**，若为0，则说明结果不为0，故此时oprd1>oprd2
       当有符号时：
       若SF=0，OF=0 则说明了此时的值为正数，没有溢出，可以直观的看出，oprd1>oprd2
       若SF=1，OF=0 则说明了此时的值为负数，没有溢出，则为oprd1<oprd2
       若SF=0，OF=1 则说明了此时的值为正数，有溢出，可以看出oprd1<oprd2
       若SF=1，OF=1则说明了此时的值为负数，有溢出，可以看出oprd1>oprd2
       最后两个可以作出这种判断的原因是，溢出的本质问题：
       两数同为正，相加，值为负，则说明溢出
       两数同为负，相加，值为正，则说明溢出
       故有，正正得负则溢出，负负得正则溢出
	   
	[详细参考](http://laokaddk.blog.51cto.com/368606/284280/)
   10.跳转指令
      * 无条件跳转：JMP
      * 根据CX、ECX寄存器的值跳转：JCXZ（CX为0则跳转）、JECXZ（ECX为0则跳转）
      * 根据EFLAGS寄存器的标志位跳转，列表如下： 
	    JE   ;等于则跳转
	    JNE  ;不等于则跳转

	    JZ   ;为 0 则跳转
	    JNZ  ;不为 0 则跳转

	    JS   ;为负则跳转
	    JNS  ;不为负则跳转

	    JC   ;进位则跳转
	    JNC  ;不进位则跳转

	    JO   ;溢出则跳转
	    JNO  ;不溢出则跳转

	    JA   ;无符号大于则跳转
	    JNA  ;无符号不大于则跳转
	    JAE  ;无符号大于等于则跳转
	    JNAE ;无符号不大于等于则跳转

	    JG   ;有符号大于则跳转
	    JNG  ;有符号不大于则跳转
	    JGE  ;有符号大于等于则跳转
	    JNGE ;有符号不大于等于则跳转

	    JB   ;无符号小于则跳转
	    JNB  ;无符号不小于则跳转
	    JBE  ;无符号小于等于则跳转
	    JNBE ;无符号不小于等于则跳转

	    JL   ;有符号小于则跳转
	    JNL  ;有符号不小于则跳转
	    JLE  ;有符号小于等于则跳转
	    JNLE ;有符号不小于等于则跳转

	    JP   ;奇偶位置位则跳转
	    JNP  ;奇偶位清除则跳转
	    JPE  ;奇偶位相等则跳转
	    JPO  ;奇偶位不等则跳转
## 实模式与保护模式
   保护模式同实模式的根本区别是进程内存受保护与否 。可寻址空间的区别只是这一原因的果 
   ### 实模式
       将整个物理内存看成分段的区域,程序代码和数据位于不同区域，系统程序和用户程序没有区别对待，而且每一个指针都是指向"实在"的物理地址。
	   这样一来，用户程序的一个指针如果指向了系统程序区域或其他用户程序区域，并改变了值，那么对于这个被修改的系统程序或用户程序，其后果就很可能是灾难性的。
	   为了克服这种低劣的内存管理方式，处理器厂商开发出保护模式
   ### 保护模式
       物理内存地址不能直接被程序访问，程序内部的地址（虚拟地址）要由操作系统转化为物理地址去访问，程序对此一无所知。
	   至此，进程（这时我们可以称程序为进程了）有了严格的边界，任何其他进程根本没有办法访问不属于自己的物理内存区域，
	   甚至在自己的虚拟地址范围内也不是可以任意访问的，因为有一些虚拟区域已经被放进一些公共系统运行库。这些区域也不能随便修改，
	   若修改就会有: SIGSEGV（linux 段错误）;非法内存访问对话框（windows 对话框）
   ### 补充
       保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，
	   因而最多可以同时存在2 * 2^13 = 2^14个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，
	   很大程度上各个段的地址空间是相互重叠的。目前所谓的64TB（2^(14+32)=2^46）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，
	   真正的物理空间仍然只有2^32字节那 么大。注：在ucore lab中只用到了GDT，没有用LDT
           
## 作业
   ### 把寄存器全部设置成0的状态，然后执行下面的代码：
       mov eax,0a1234h	    ;将十六进制数0a1234h送入eax
       mov bx,ax			;将ax内容送入bx
       mov ah,bl			;将bl内容送入ah
       mov al,bh			;将bh内容送入al
      思考此时EAX的内容是多少?
      答：0a1234h转化为二进制为1010 0001 0010 0011 0100
         则ax为0001 0010 0011 0100 -- bx为0001 0010 0011 0100
	     bl为0011 0100 -- ah为0011 0100
		 bh为0001 0010 -- al为0001 0010
	     故此时EAX的内容是0000 0000 0000 1010 0011 0100 0001 0010
       
       
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   
	   