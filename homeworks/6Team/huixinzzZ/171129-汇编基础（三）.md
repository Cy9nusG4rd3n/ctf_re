1. 理解内容并做学习笔记。
## 操作内存
我们可以将内存想象为一个顺序的字节流。操作内存是，首先需要的就是他的地址。  

`mov ax,[0]`

`方括号`表示，里面的表达式指定的不是`立即数`，而是`偏移量`。  
在实模式中，`DS:0`中的那个`字`会被装入AX。  
`mov [0],ax`

mov指令也可以把数据保存到内存中。
### 描述内存宽度的操作符

|  操作符 | 意义  |
| :------------ | :------------ |
|  byte ptr | 一个字节（8-bit，1 byte）  |
|  word ptr | 一个字（16-bit）  |
|  dword ptr | 一个双字（32-bit）  |



### 串操作
前面说到，内存可以和寄存器交换数据，也可以被赋予立即数。  
问题是，如果我们需要把**内存的某部分内容**复制到另一个地址，要怎么操作呢？  
设想将DS:SI处的连续512字节内容复制到ES:DI（不考虑可能的重叠）：
```
			mov cx,512			;循环次数
NextByte:	mov al,ds:[si]
			mov es:[si],al
			inc si
			inc di
			loop NextByte
```
这是一种不太完美的解决方法，因为效率不好。  

Intel的CPU的强项是**串操作**。所谓串操作就是由CPU去完成**某一数量的重复的内存操作**。

某些指令可以加上**REP前缀**，这些指令通常被叫做**串操作指令**。  
举例来说  
**STOSD**指令将`EAX`的内容保存到`ES:DI`，同时在**DI**上加/减`4`；  
**STOSB**和**STOSW**分别作**1字节**或**1字**的操作，在**DI**上加/减的数是`1`或`2`。  
在**DI**上是加还是减，取决于**DF**标志，如果DF被**复位**，则加；   反之则减。  
**置位、复位**的指令分别是**STD、CLD**。

除了**REP**，常用的前缀还包括`REPNE`、`REPZ`、`REPE`、`REPNZ`等。
***
按**计数寄存器 ((E)CX)** 中指定的次数重复执行字符串指令，  
或是重复到 **ZF标志**不再满足指定的条件。  


前缀 | header 2
---|---
REP| 重复
REPE | 相等时重复
REPNE| 不相等时重复
REPZ | 为零时重复
REPNZ|不为零时重复

REP、REPE、REPNE、REPZ及 REPNZ**助记符**都是可以添加到一些字符串指令中的前缀。

**REP 前缀**可以添加到 INS、OUTS、MOVS、LODS 及 STOS 指令，  
**REPE、REPNE、and REPZ 、 REPNZ 前缀**可以添加到 CMPS 与 SCAS 指令。  
 （`REPZ 与 REPNZ` 前缀分别是 `REPE 与 REPNE` 前缀的同义形式）。  
同非字符串指令一起使用时，REP 前缀的行为未定义。

**REP 前缀**一次只能应用于一条字符串指令。要重复指令块，请使用 LOOP 指令或其它循环结构。

所有这些**重复前缀**都会使**关联的指令重复执行**，直到**寄存器 (E)CX** 中的计数递减到 0（请参阅下表）。  
（如果**当前地址大小属性为 32**，则将寄存器 ECX 用作计数器；  
如果**大小属性为 16**，则将 CX 寄存器用作计数器）。  

在每次**迭代**之后，`REPE、REPNE、REPZ 及 REPNZ` 前缀还会检查 **ZF 标志**的状态，  
如果 ZF 标志未处于指定的状态，则终止重复循环。  
同时测试两个终止条件时，**终止重复的原因**可以通过使用 **JECXZ 指令**来测试
**(E)CX 寄存器**进行确定，  
也可以通过使用 JZ、JNZ 及 JNE 指令来**测试 ZF 标志**进行确定。

| 重复前缀  | 终止条件1  | 终止条件2  |
| :------------ | :------------ | :------------ |
| REP  | ECX=0  | 无  |
| REPE/REPZ  | ECX=0  | ZF=0  |
| REPNE/REPNZ  | ECX=0  | ZF=1  |

**使用 REPE/REPZ 与 REPNE/REPNZ 前缀时，由于 CMPS 与 SCAS 指令都会根据它们的比较结果设置 ZF 标志，因此 ZF 标志不需要初始化。**

所以，我们可以把上面的程序
```
			mov cx,512			;循环次数
NextByte:	mov al,ds:[si]
			mov es:[si],al
			inc si
			inc di
			loop NextByte
```
改写为如下：
```
cld			;复位DF
mov cx,128		;512/4=128，共128个双字
rep movsd
```


2. 准备工具：OllyDBG并熟悉界面／功能。

![image](https://github.com/huixinzzZ/ctf_re/blob/master/src/ollydbg.png?raw=true)
* 反汇编窗口：显示被调试程序的反汇编代码，标题栏上的地址、HEX 数据、反汇编、注释可以通过在窗口中右击出现的菜单 界面选项->隐藏标题 或 显示标题 来进行切换是否显示。用鼠标左键点击注释标签可以切换注释显示的方式。
* 寄存器窗口：显示当前所选线程的 CPU  
* 寄存器内容。同样点击标签 寄存器 (FPU)   可以切换显示寄存器的方式。
* 信息窗口：显示反汇编窗口中选中的第一个命令的参数及一些跳转目标地址、字串等。
* 数据窗口：显示内存或文件的内容。右键菜单可用于切换显示方式。  
* 堆栈窗口：显示当前线程的堆栈。