### 栈
+ 栈是计算机科学里最重要的且最基础的数据结构之一。从技术上讲，栈就是CPU寄存器里面的某个指针所指向的一片内存区域。这里所说的`某个指针`通常位于x86/x64平台的`ESP寄存器/RSP寄存器`，以及ARM平台的`SP寄存器`。 
+ **PUSH指令**：对ESP/RSP/SP寄存器的值进行减法运算，使之减去4(32位）或8(64位）（注意：写汇编代码时，可以push一个16位的数据，这样栈顶会减去2，但是由于编译器会做32位对齐，所以我们看到的基本上都是加减4或8的情况。），然后将操作数写到上述寄存器里的指针所指向的内存中。
+ **POP指令**：PUSH的逆操作：他先从栈指针（Stack Pionter,上面三个寄存器之一）指向的内存中读取数据，用以备用（通常是写到其他寄存器里面），然后再将栈指针的数值加上4或8。
+ PUSH将减少栈指针的数值，而POP会增加它的数值。**原因**：栈指针，即Stack Pointer所**指向的地址是栈的底部**，栈的“底”实际上使用的是整个栈的最低地址，即是整个栈的启始内存地址。 ARM的栈分为递增栈和递减栈。递减栈（descending stack)的首地址是栈的最高地址，栈向低地址增长，栈指针的值随栈的增长而减少，如STMFA/LMDFA、STMFD/LDMFD、STMED、LDMEA等指令，都是递增栈的操作指令。。
#### 栈的用途
##### 保存函数结束时的返回地址

x86

当程序使用call指令调用其他函数时，call指令结束后的返回地址将被保存到栈里，在call所调用的函数结束之后，程序将执行无条件跳转指令，跳转到这个返回地址。 call指令等价于“PUSH返回地址”和“JMP函数地址”的指令对 被调用函数里的RET指令，会从栈中读取返回地址，然后跳转到这个这个地址，就相当于“POP返回地址”+“JMP返回地址”指令。 栈是有限的，溢出它很容易。直接使用无线递归，栈就会满：
```
#无限递归
void f()
{
	f();
}
```
编译运行会报错。
```
warning C4717:’f’ : recursive on all control paths. Function will cause runtime stack overflow
```
但它还是会生成汇编文件；
有趣的是,如果打开优化选项“/Ox”,生成的程序反而不会出现栈溢出的问题,而且还会运行得很“好”；
无论是否开启优化选项,GCC 4.4.1 生成的代码都和 MSVC 生成的代码相似,只是 GCC 不会发布任何警告。

ARM

+ ARM程序也使用栈保存返回地址，只是略有不同。之前课程中我们看到“hello world"程序的返回地址保存在[LR寄存器](https://baike.baidu.com/item/LR/17186721?fr=aladdin)里。但是如果程序还会继续调用其它函数，就需要在调用函数之前保存LR寄存器里面的值。通常函数会在启动过程中（序言处）保存LR寄存器的值。我们通常在函数序言中看到`PUSH R4-R7,LR`,并在尾声处看到`POP R4-R7,PC`。这些指令会对函数自身将要用到的寄存器进行保护，把它们的值存放到栈中（当然，这其中也包括LR寄存器）。
+ 如果一个函数不调用其它函数，它就像书上枝杈末端的叶子一样，这种函数被叫做`叶函数（leaf function）`。叶函数的特点是：它不必保存LR寄存器的值。如果叶函数的代码短到用不到几个寄存器,那么它也可能根本不会使用数据栈。所以调用叶函数的时候确实可能不会涉及栈操作。由于这种代码不在外部内存RAM进行与栈有关的操作,所以它的运行速度有可能超过x86 系统，在没有分配栈或者不可能用栈的时候,这类函数就会显现出“寸有所长”的优势。

#### 参数传递
在x86 平台的程序中,最常用的参数传递约定是cdecl 。以cdecl方式处理参数,其上下文大体是这个样子:
```
push arg3
push arg2
push arg1
call f
add esp,12 4*3=12
```
被调用方函数（Callee functiongs)通过栈指针获取其所需的参数。 在运行f()函数之前，传递给他的参数将以以下格式存储到内存里：

|  ESP  |  返回地址  |
| :---: | :---: |
|  ESP+4  |  arg1,它在IDA里面记为arg0  |
|  ESP+8  |  arg2,它在IDA里面记为arg4  |
|  ESP+0xC  |  arg4,它在IDA里面记为arg8|

程序员可以使用栈来传递参数，也可以不使用栈来传递参数。参数处理方面并没有相关的硬性规定。 例如，程序员可以在堆（heap）中分配内存并用之传递参数。在堆中放入参数之后,可以利用EAX寄存器为函数传递参数。这种做法确实行得通。只是在x86 系统和ARM系统上,使用栈处理参数已经成为了约定俗成的习惯,而且它的确十分方便。
注：调用参数必须事先在函数中定义，才能使用对应的参数。

##### 存储局部变量
通过向栈底调整栈指针的方法，函数即可在数据栈里分配出一片可用于存储局部变量的内存空间。可见，无论函数声明了多少个变量，都不影响它分配栈空间的速度。 虽然可以在栈外的任何地方存储局部变量，但是用数据栈来存储局部变量已经是一种约定俗成的习惯了。

##### 申请内存函数  allocal()
`alloca()`函数直接使用栈来分配内存，除此之外，它与`malloc()`函数没有显著的区别. 函数尾声的代码还会还原ESP的值，把数据栈还原为函数启动之前的状态，**直接抛弃**由alloca()函数分配的内存，所以程序不需要特地使用`free函数`来释放由这个函数申请的内存。 
```
#ifdef __GNUC__
#include <alloca.h> // GCC
#else
#include <malloc.h> // MSVC
#endif
#include <stdio.h>
void f()
{
char *buf=(char*)alloca (600);
#ifdef __GNUC__
snprintf (buf, 600, "hi! %d, %d, %d\n", 1, 2, 3); // GCC
#else
_snprintf (buf, 600, "hi! %d, %d, %d\n", 1, 2, 3); // MSVC
#endif
puts (buf);
}
```
snprint()函数的功能和printf()函数的功能差不多。prinf函数将输出结果输出到stdout（也就是终端terminal或console一类的输出设备上），而snprintf()则将结果输出到buf数组（人工设定的缓冲区）、我们需要通过puts()函数才能将buf的内容输出到stdout。当然printf()函数就足以完成_snprintf()和puts()两个函数的功能。主要为了演示缓冲区的用法，所以才可以将它拆分为两个函数。 MSVC 现在使用 MSVC 2010 编译上面的代码,得到的代码段如下所示。 
```
...
	mov eax,600      ;00000258H
	call __alloca_probe_16
	mov esi,esp
	push 3
	push 2
	push 1
	push SFFSET $SG2672
	push 600          ;00000258H
	push esi
	call _puts
	add esp,28        ;000001cH
...
```
由于alloca()函数是编译器固有函数，并非常规函数的缘故，这个程序并没有使用栈，而是使用EAX寄存器来传递alloca()函数唯一的参数。在调用alloca()函数之后，ESP将指向600字节大小的内存区域，用以存储数组buf。
#### (Windows)SEH 结构化异常处理
如果程序里存在 SEH 记录,那么相应记录会保存在栈里。
#### 典型的栈的内存存储格式
在 32 位系统中,在程序调用函数之后、执行它的第一条指令之前,栈在内存中的存储格式一般如下表所示。

|...|...|
|:---:|:---:|
|ESP-0xC|第 2 个局部变量,在 IDA 里记为 var_8|
|ESP-8|第 1 个局部变量,在 IDA 里记为 var_4|
|ESP-4|保存的 EBP 值|
|ESP|返回地址|
|ESP+4|arg1, 在 IDA 里记为 arg_0|
|ESP+8|arg2, 在 IDA 里记为 arg_4|
|ESP+0xC|arg3, 在 IDA 里记为 arg_8|
|...|...|

教程参考地址：https://github.com/DigBullTech-Michael/ctf_re/blob/master/tutorials/171213_7th.md