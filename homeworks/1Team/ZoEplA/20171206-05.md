### 子程序
 汇编语言并不注重程序员的负担，它依赖程序员的良好设计，以期发挥CPU的最佳性能。 汇编语言不是结构化的语言，它不提供直接的“局部变量”。如果需要，只能通过`堆或栈`自行实现。
参数的传递是靠`寄存器或堆栈`来完成的。高级语言中，子程序（函数／过程，或者类似概念的东西）依赖于堆和栈来传递。
#### 子程序的执行过程
##### 基本知识储备
+ 所有的命令都是存储在cs：ip代表的地址中，cs就是段地址，IP中存放着偏移
+ BP称为指针寄存器，与SS连用，为访问现行堆栈段提供方便。(通常BP寄存器在间接寻址中使用，操作数在堆栈段中，由SS段寄存器和BP组合形成操作数的地址，即BP中存放现行堆栈段中一个数据区的“基址”的偏移量，所以称BP为基址指针)
+ bp：基址寄存器(stack pointer)，一般在函数中用来保存进入函数时的sp的栈顶基址
+ SP,BP一般与段寄存器SS 联用，以确定堆栈寄存器中某一单元的地址，SP用以指示栈顶的偏移地址，而BP可 作为堆栈区中的一个基地址，用以确定在堆栈中的操作数地址。
+ BP:  基数指针寄存器BP(base pointer)是一个寄存器，它的用途有点特殊，是和堆栈指针SP联合使用的，作为SP校准使用的，只有在寻找堆栈里的数据和使用个别的寻址方式时候才能用到
+ ret 用栈中数据改IP内容,近转移
retf用栈中数据同时改CS,IP,远转移
用汇编解释:
ret   ->  pop ip
retf  ->  pop ip  
			 pop cs
+ LEA指令取源操作数地址的偏移量，并把它传送到目的操作数所在的单元。（LEA取有效地址指令）
+ cdq，意为将双字数据扩展为四字。大多出现在除法运算之前. 它实际的作用只是把EDX的所有位都设成EAX最高位的值。该指令先把edx的每一位置成eax的最高位（若eax>=0x80000000, 则edx=0xFFFFFFFF；若eax<0x80000000，则edx=0x00000000） ，再把edx扩展为eax的高位。
+ DIV (unsigned divide) 无符号数除法；
IDIV 带符号除法指令。
 
参考：https://github.com/DigBullTech-Michael/ctf_re/edit/master/tutorials/171204_5th.md
无论是C／C++／BASIC／Pascal，子程序的执行过程基本都是一致的。
- 调用者将子程序执行完成时应返回的地址／参数压入堆栈。
- 子程序使用`BP指针+偏移量`对栈中的参数`寻址`，并取出，完成操作。
- 子程序使用`RET`或`RETF`指令返回。此时，CPU将`IP`置为堆栈中保存的地址，并继续予以执行。

毋庸置疑，堆栈在整个过程中发挥着非常重要的作用。不过，本质上对子程序最重要的还是`返回地址`，如果子程序不知道这个地址，那么系统将会崩溃。
调用子程序的指令是`CALL`，对应的返回指令是`RET`，另外还有`ENTER`和`LEAVE`，她们可以帮助进行堆栈的维护。

`CALL`指令的参数是`被调用子程序的地址`。使用宏汇编的时候，这通常是一个标号。CALL和RET，一级ENTER和LEAVE配对，以实现`对堆栈的自动操作`，而不需要程序员进行PUSH/POP，以及跳转的操作，从而提高了效率。

实例展示说明：
高级程序语言代码展示：
```
//c++
int myTransform(int nInput){
  return (nInput*2+3) %7;
}

int main(int argc, char* argv[])
{
  int a[3];
  for(register int i=0;i<3;i++){
    a[i] = myTransform(i);
  }
  return 0;
}
```
作者编译出来，并且合并了C++代码和汇编代码：
```
int myTransform(int nInput){
//00401000 push ebp		;保护现场原先的EBP指针
//00401001 mov ebp,esp
return (nInput*2+3)%7;
//00401003 mov eax,dword ptr [nInput]		;取参数
//00401006 lea eax,[eax+eax+3]		;LEA比ADD加法更快
//0040100A cdq		;DWORD -> QWORD（扩展字长）
//0040100B mov ecx,7		;除数
//00401010 idiv ecx		;除
//00401012 mov eax,edx		;余数->eax（eax中保存返回值）
}

//00401014 pop ebp		;恢复现场的EBP指针
//00401005 ret		;返回

//; 此处删除10条int 3指令，不会影响程序行为

int main(int argc, char* argv[])
{
//00401020 push ebp		;保护现场原先的EBP指针
//00401021 mov ebp,esp
//00401023 sub esp,10h		;为取argc/argv修正堆栈指针

int a[3];
for(register int i=0;i<3;i++){
	//00401026 mov dword ptr [i],0		;0->i
	//0040102D jmp main+18h(00401038)		;判断循环条件
	//0040102F mov eax,dword ptr [i]		;i->eax
	//00401032 add eax,1		;EAX++
	//00401035 mov dword ptr [i],eax		;eax -> i
	//00401038 cmp dword ptr [i],3; 循环条件：i与3比较
	//0040103C jge main+33h(00401053)		;如果不符合条件，则应结束循环
	a[i] = myTransform[i];
	//0040103E mov ecx,dword ptr [i]		;i->ECX
	//00401041 push ecx		;ecx(i) -> 堆栈
	//00401042 call myTransform(00401000)		;调用myTransform
	//00401047 add esp,4		;ESP+4:在堆中的新单元

	//;准备存放返回结果
	//0040104A mov edx,dword ptr [i]		;i->EDX
	//0040104D mov dword ptr [edx*4],eax		;将EAX(即myTransform的返回值)放回a[i]

}
//00401051 jmp main+0Fh(0040102F)		;计算出i++，并继续循环
return 0;
//00401053 xor eax,eax		;返回值应该是0

}
//00401055 mov esp,ebp		;恢复堆栈指针
//00401057 pop ebp		;恢复BP
//00401058 ret		;返回调用者(C++运行环境)
```

```
00401003 mov eax,dword ptr [nInput]		;取参数
```
这句话在另外一个反汇编器得到的结果是：
```
00401003 mov eax,dword ptr [ebp+8]		;取参数
```
#### 思考与总结
1. call在汇编中起到调用子程序的作用，在汇编中调用函数一般都会用参数的压栈和出栈来表示。参数一般都是依赖寄存器和堆栈来进行。
2. 调用函数前都有一个ebp作为保护现场的指针，在函数调用结束时可以利用堆栈和ebp寄存器回复现场。
3. jmp条件跳转结合cmp比较函数和jge函数实现循环。
jge和jae函数跳转：
```
jge 
转移条件：sf异或of=0  
转移说明：大于等于转移 
其他说明：有符号数，两个标志位sf和of
jae 
转移条件：cf=0 	
转移说明：不低于，或者高于等于，或者进位标志转移清零时转移
其他说明：单个标志，无符号数

在转移指令之前有test、cmp等比较指令
```
4. 自身进行异或运算自身赋值为0。

学习记录：
div与idiv执行的操作：
```
　　字节操作：16位被除数在AX，8位除数为源操作数，结果的8位商在AL中，8位余数在AH中。表示为

　　（AL）<-(AX)/(SRC) 的商
　　 (AH) <-(AX)/(SRC) 的余数

　　字操作：32位被除数放在DX,AX中。其中DX为高位字，16位除数为源操作数，结果的16位端在AX中，16位余数在DX中。表示为
　　(AX)<-(DX,AX)/(SRC) 的商
　　(DX)<-(DX,AX)/(SRC) 的余数

　　双字操作:64位被除数在EDX,EAX中，其中EDX为高位双字，32位除数为源操作数，结果的32位商在EAX中，32位余数在EDX中，表示为
　　(EAX)<-(EDX,EAX)/(SRC) 的商
　　(EDX)<-(EDX,EAX)/(SRC) 的余数。
```
逆向入门书籍：
《RE4B》：https://beginners.re/

### 中断
这个在操作系统的课堂上讲的很多，对于程序的正常中断、非正常中断的解释等等。但中断在操作系统中却起到不可或缺的作用。中断可以说是计算机操作系统提供的一个特殊子程序，他一般是由系统本身来调用的。
#### 名词解析：
##### DMA：直接存储器访问
DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。

1. 中断向量表：保存在系统数据区（实模式下，是0:0开始的一段区域）的一组指针。这组指针指向每个中断服务程序的地址。整个中断向量表的结构是一个线性表。
2. 中断号：每个中断服务都有自己的唯一编号。每一个中断号对应中断向量表中的一项，也就是一个中断的向量。外设向驼背发出中断请求，而CPU自己将根据当前的程序状态决定是否中断当前程序并调用相应的中断服务。
3. 不难根据造成中断的原因将中断分为两类：硬件中断和软件中断
4. 调用中断的指令是：int 中断号
5. 很多时候，中断服务程序必须写成可重入代码（或纯代码，pure code）。所谓可重入代码是指，程序的运行过程中可以被打断，并由开始处再次执行，并且执行结果不受影响。


